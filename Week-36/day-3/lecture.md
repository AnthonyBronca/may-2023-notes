# SQLAlchemy and Alembic

## Alembic

Alembic is how we can manage our migrations in a Flask Application. Back in Express, Sequelize was a one-thing-do-all, because it could do our migrations, models, and seeds all out of the box. In exchange for that, we had to manually write our own migrations. Sure we could use the CLI commands to generate some files, and prepopulate some objects with some cli specified key-words, but Alembic is a powerful tool that can read out models and generate migrations pretty acuratelt to what we want.


### Set-Up

Make sure to install:

```
alembic
flask-migrate
```

Here is a general requirements.txt for a lot of the content we need to build a solid backend with flask:

```
alembic==1.6.5
click==7.1.2
flask-cors==3.0.8
flask-login==0.5.0
flask-migrate==3.0.1
flask-sqlalchemy==2.5.1
flask-wtf==0.15.1
flask==2.0.1
greenlet==1.1.0
gunicorn==20.1.0
itsdangerous==2.0.1
jinja2==3.0.1
mako==1.1.4
markupsafe==2.0.1
python-dateutil==2.8.1
python-dotenv==0.14.0
python-editor==1.0.4
six==1.15.0
sqlalchemy==1.4.19
werkzeug==2.0.1
wtforms==2.3.3
email-validator
boto3
psycopg2-binary
```
In order to set up our migrations, we need to hook up `flask-migrate` to our flask app.
In app/__init__.py, we can import `Migrate`, and pass in our app and database.

```py
from flask import Flask, render_template
from .config import Config
from .models import db, Tweet, User, Tweet_Image
from flask_migrate import Migrate
from .seeds import seed_commands

app = Flask(__name__)
app.cli.add_command(seed_commands)
app.config.from_object(Config)
db.init_app(app)
Migrate(app, db)
```

Now we can use some cli commands to migrate!

In your terminal (if outside of the shell), run:

```
pipenv run flask db init
```

This will generate a migrations folder (but it will be empty)

Then run:

```
pipenv run flask db migrate
```

To populate our `versions` directory with a migrations file! Also, while we are using "migrate", these are technically called revisions and versions. In alembic, we have one revision file that has all of our migrations, instead of how sequelize worked where had multiple different migration files. You should have an output like this:

```py
"""empty message

Revision ID: 8aead516a74e
Revises:
Create Date: 2024-01-23 00:55:09.318215

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '8aead516a74e'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=30), nullable=False),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('tweets',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('tweet_content', sa.String(length=255), nullable=False),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['users.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('tweet_images',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('image_url', sa.String(length=1000), nullable=False),
    sa.Column('tweet_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['tweet_id'], ['tweets.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('tweet_images')
    op.drop_table('tweets')
    op.drop_table('users')
    # ### end Alembic commands ###

```

The `op` command, stands for `operation`, and it allows us to run SQL commands using python. the `sa` command stands for SQLAlchemy. In our models we used, `db` because we had done:

```py
db = SQLALchemy()
```

but here they use `sa` because they imported SQLAlchemy as `sa`.

Some other differences in SQLAlchemy vs Alembic files, is that primary_key is now `PrimaryKeyConstaint`, and ForeignKey is now `ForeignKeyConstraint`.

One thing to note, we may have to adjust these files manually. Especially during projects, when we need to include code to handle our SCHEMA truncations and Production vs Development environments.

Lastly, notice that we have our downgrade command in a specific order. We want to drop the the thing with the least amount of connections first to avoid bugs. We can't drop `users` first, because `tweets` is using an id as a FK from `users`. So keep that in mind!


## SQLALchemy Seeds

Sequelize came built in with some Sequelize-cli commands we could install in order to do things like:
```
npx dotenv sequelize db:seed:all
```

If we want that same functionality, we will need to set up the structure ourselves.

Let's create a Seed folder, in which we can have an __init__.py file, and also a seed.py file.

The __init__.py file will create our function in the cli, and then hook that up to the app. The seed.py file will let us create functions that we want to run to insert into the database.



In the __init__.py, we will want to do something like this:

```py

from flask.cli import AppGroup
from .seeds import seed_tweet_images, seed_tweets, seed_users
from ..models import db

seed_commands = AppGroup("seed")


@seed_commands.command("all")
def seed():
    seed_users()
    seed_tweets()
    seed_tweet_images()


@seed_commands.command("undo")
def undo():
    db.session.execute("DELETE FROM tweet_images")
    db.session.execute("DELETE FROM tweets")
    db.session.execute("DELETE FROM users")
    db.session.commit()


```


What we are doing is importing `flask.cli` which comes from `flask`. We want the `AppGroup` class so that we can develop our own CLI commands.

Once we create a variable to `AppGroup`, we can pass in the command we want to use: `seed`.

Now we can specify what the arguments will be:

`all`, Will allow us to seed all by running the 3 functions from our seeder file.
`undo`, will allow us to unseed all by running the SQL Execution. Don't forget to commit in the undo!


Our /seeds/seeds.py file will look like:

```py
from ..models import User, Tweet, Tweet_Image, db
from random import choice


def seed_users():
    anthony = User(
        name="Anthony",
    )
    sam = User(
        name="Sam",
    )
    will = User(
        name="Will",
    )
    edward = User(
        name="Edward",
    )

    db.session.add(anthony)
    db.session.add(sam)
    db.session.add(will)
    db.session.add(edward)
    db.session.commit()


def seed_tweets():
    random_tweets = [
        "I am a tweet",
        "Hello there",
        "Hello world?",
        "Who would tell me where the closest burger joint is?",
        "Sqlalchemy can be cool",
        "Migrations.. migrations... migrations!",
        "No wait... revisions!",
    ]

    for i in range(0, 10):
        tweet = Tweet(tweet_content=choice(random_tweets), user_id=choice([1, 2, 3, 4]))
        db.session.add(tweet)
    db.session.commit()


def seed_tweet_images():
    for i in range(1, 10):
        tweet_image = Tweet_Image(image_url="image.url", tweet_id=i)
        db.session.add(tweet_image)
    db.session.commit()

```

Notice we are doing the commit *ONCE* here, although we can add many times before commiting.

The last thing we need to do is hook up these commands to our App. We can do this in the __init__.py of our app like so:

```py
from .config import Config
from .models import db, Tweet, User, Tweet_Image
from flask_migrate import Migrate
from .seeds import seed_commands # <--- imports the seed command we just made

app = Flask(__name__)
app.cli.add_command(seed_commands) # <----- Adds the seed command we jsut made
app.config.from_object(Config)
db.init_app(app)
Migrate(app, db)


```


Now all we need to do to set up our database is:


```
pipenv run flask db init
pipenv run flask db migrate
pipenv run flask seed all
pipenv run flask run

```

And we are good to go! We now have a flask application running with our models creating migrations, our migrations creating the database, and our seeders filling that database. And we can use SQLAlchemy in our flask app to query using the models! We now know how to build a full backend with Python!
